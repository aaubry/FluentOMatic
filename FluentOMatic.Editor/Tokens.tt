//    Copyright 2012 Antoine Aubry
//    
//    This file is part of FluentOMatic.
//
//    FluentOMatic is free software: you can redistribute it and/or modify
//    it under the terms of the GNU General Public License as published by
//    the Free Software Foundation, either version 3 of the License, or
//    (at your option) any later version.
//
//    FluentOMatic is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//    GNU General Public License for more details.
//
//    You should have received a copy of the GNU General Public License
//    along with FluentOMatic.  If not, see <http://www.gnu.org/licenses/>.

<#@ template language="C#" debug="True" hostspecific="False"
#><#@ assembly name="Microsoft.CSharp"
#><#@ assembly name="System.Core.dll"
#><#@ assembly name="System.Data"
#><#@ assembly name="System.Xml"
#><#@ assembly name="System.Configuration"
#><#@ import namespace="System.Collections.Generic"
#><#@ import namespace="System.Diagnostics"
#><#@ import namespace="System.Globalization"
#><#@ import namespace="System.IO"
#><#@ import namespace="System.Linq"
#><#@ import namespace="System.Text"
#><#@ import namespace="System.Text.RegularExpressions"
#><#@ import namespace="System.Configuration"
#><#
	var tokens = new dynamic[]
	{
		new { Name = "Dot", Classification = "Operator" },
		new { Name = "Identifier", Classification = "Identifier" },
		new { Name = "Number", Classification = "Number" },
		new { Name = "OpenParen", Classification = "Operator" },
		new { Name = "CloseParen", Classification = "Operator" },
		new { Name = "ZeroOrMany", Classification = "Keyword" },
		new { Name = "ZeroOrOne", Classification = "Keyword" },
		new { Name = "OneOrMany", Classification = "Keyword" },
		new { Name = "Comma", Classification = "Operator" },
		new { Name = "Syntax", Classification = "Keyword" },
		new { Name = "String", Classification = "SymbolReference" },
		new { Name = "Using", Classification = "Keyword" },
		new { Name = "EndOfUsing", Classification = "Operator" },

		// Extra
		new { Name = "Type", Classification = "SymbolReference" },
		new { Name = "Parameter", Classification = "SymbolDefinition" },
		new { Name = "SyntaxName", Classification = "String" },
		new { Name = "Namespace", Classification = "String" },
	}
	.Select(t =>
	{
		try
		{
			return new { Name = (string)t.Name, Classification = (string)t.Classification, Foreground = (string)null, Background = (string)null };
		}
		catch (Exception)
		{
			return new { Name = (string)t.Name, Classification = (string)null, Foreground = (string)t.Foreground, Background = (string)t.Background };
		}
	});


#>
using System.ComponentModel.Composition;
using System.Windows.Media;
using Microsoft.VisualStudio.Language.StandardClassification;
using Microsoft.VisualStudio.Text.Classification;
using Microsoft.VisualStudio.Utilities;

namespace FluentOMatic.Editor
{
	partial class Editor
	{
		private IClassificationType[] _classificationTypes;

		internal Editor(IClassificationTypeRegistryService registry)
		{
			_classificationTypes = new[]
			{
<#
	foreach(var token in tokens)
	{
		if(token.Classification == null)
		{
#>
				registry.GetClassificationType("FluentOMatic.<#= token.Name #>"),
<#
		}
		else
		{
#>
				registry.GetClassificationType(PredefinedClassificationTypeNames.<#= token.Classification #>),
<#
		}
	}
#>
			};
		}

		private static class TokenType
		{
<#
	foreach(var token in tokens.Select((t, i) => new { Name = t.Name, Index = i + 1 }))
	{
#>
			public const int <#= token.Name #> = <#= token.Index #>;
<#
	}
#>
		}
	}

    internal static class EditorClassificationDefinition
    {
<#
	foreach(var token in tokens.Where(t => t.Classification == null))
	{
#>
        [Export(typeof(ClassificationTypeDefinition))]
        [Name("FluentOMatic.<#= token.Name #>")]
        internal static ClassificationTypeDefinition <#= token.Name #>EditorType = null;

<#
	}
#>
    }

<#
	foreach(var token in tokens.Where(t => t.Classification == null))
	{
#>
    [Export(typeof(EditorFormatDefinition))]
    [ClassificationType(ClassificationTypeNames = "FluentOMatic.<#= token.Name #>")]
	[Name("FluentOMatic.<#= token.Name #>")]
    [UserVisible(true)] //this should be visible to the end user
    [Order(Before = Priority.Default)] //set the priority to be after the default classifiers
    internal sealed class <#= token.Name #>EditorFormat : ClassificationFormatDefinition
    {
        /// <summary>
        /// Defines the visual format for the "FluentOMatic.Editor" classification type
        /// </summary>
        public <#= token.Name #>EditorFormat()
        {
			DisplayName = "FluentOMatic.<#= token.Name #>"; //human readable version of the name
			ForegroundColor = Colors.<#= token.Foreground #>;
            BackgroundColor = Colors.<#= token.Background #>;
        }
    }

<#
	}
#>
}
